---
layout: post
permalink: lc0733 
---

## 733 Flood Fill

图像渲染，相邻的四个方向按情况渲染

DFS
```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int m=image.length;
        int n=image[0].length;
        dfs(image,sr,sc,newColor,image[sr][sc],m,n);
        return image;
    }
    public void dfs(int[][] image, int x, int y, int newC,int oldC,int m,int n){
        if(x<0||x>=m||y<0||y>=n||image[x][y]==newC||image[x][y]!=oldC){
            return;
        }
        image[x][y]=newC;
        dfs(image,x+1,y,newC,oldC,m,n);
        dfs(image,x-1,y,newC,oldC,m,n);
        dfs(image,x,y+1,newC,oldC,m,n);
        dfs(image,x,y-1,newC,oldC,m,n);
    }
}
```

BFS
```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        /**bfs*/
        int m = image.length;
        int n = image[0].length;
        int oldcolor = image[sr][sc];
        boolean visit[][] = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{sr,sc});
        visit[sr][sc] = true;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0;i < size;i++){
                int arr[] = queue.poll();
                int a = arr[0];
                int b = arr[1];
                image[a][b] = newColor;
                if(a-1 >= 0 && !visit[a-1][b] && image[a-1][b] == oldcolor){
                    visit[a-1][b] = true;
                    queue.offer(new int[]{a-1,b});
                }
                if(a+1 < m && !visit[a+1][b] && image[a+1][b] == oldcolor){
                    visit[a+1][b] = true;
                    queue.offer(new int[]{a+1,b});
                }
                if(b-1 >= 0 && !visit[a][b-1] && image[a][b-1] == oldcolor){
                    visit[a][b-1] = true;
                    queue.offer(new int[]{a,b-1});
                }
                if(b+1 < n && !visit[a][b+1] && image[a][b+1] == oldcolor){
                    visit[a][b+1] = true;
                    queue.offer(new int[]{a,b+1});
                }
            }
        }
        return image;
    }
}
```