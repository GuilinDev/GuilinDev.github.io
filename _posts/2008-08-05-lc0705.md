---
layout: post
permalink: lc0705 
---

## 705 Design HashSet

stupid way
```java
class MyHashSet {

    /** Initialize your data structure here. */
    boolean[] arr;
    /** Initialize your data structure here. */
    public MyHashSet() {
        arr = new boolean[1000000];
    }
    
    public void add(int key) {
        arr[key] = true;
    }
    
    public void remove(int key) {
        arr[key] = false;
    }
    
    /** Returns true if this set contains the specified element */
    public boolean contains(int key) {
        return arr[key];
    }
}
```

array plus double linked list
```java
class MyHashSet {
    int capacity = 32, cnt = 0;
    MyList[] list = new MyList[capacity];;
    /** Initialize your data structure here. */
    public MyHashSet() {
        for(int i=0; i<capacity; i++){
            list[i] = new MyList();
        }
    }
    
    public void add(int key) {
        if(contains(key)) return;
        if(cnt<capacity){
            addTail(key);
        }else{// rehash
            this.capacity = capacity * 2;
            MyList[] copy = list;
            MyList[] newList = new MyList[capacity];
            for(int i=0; i<capacity; i++){
                newList[i] = new MyList();
            }
            list = newList;
            for(int i=0; i<copy.length; i++){
                ListNode head = copy[i].head;
                while(head.next!=null && head.next.val!=null){
                    addTail(head.next.val);
                    head = head.next;
                }
            }  
            addTail(key);
        }
        cnt++;
    }
    
    public void remove(int key) {
        if(!contains(key)) return;
        cnt--;
        int idx = key % capacity;
        ListNode head = list[idx].head;
        while(head.next!=null && head.next.val!=null){
            if(head.next.val==key){
                ListNode next = head.next;
                next.next.pre = head;
                head.next = next.next;
                next.pre = null;
                next.next = null;
                break;
            }
            head = head.next;
        }
    }
    
    /** Returns true if this set contains the specified element */
    public boolean contains(int key) {
        int idx = key % capacity;
        ListNode head = list[idx].head;
        while(head.next!=null && head.next.val!=null){
            if(head.next.val==key) return true;
            head = head.next;
        }
        return false;
    }
    
    private void addTail(int key){
        int idx = key % capacity;
        ListNode tail = list[idx].tail;
        ListNode pre = tail.pre;
        ListNode cur = new ListNode(key);
        pre.next = cur;
        cur.pre = pre;
        cur.next = tail;
        tail.pre = cur;
    }
}
class MyList{
    public ListNode head;
    public ListNode tail;
    public MyList(){
        head = new ListNode();
        tail = new ListNode();
        head.next = tail;
        tail.pre = head;
    }
}
class ListNode{
    public Integer val;
    public ListNode next;
    public ListNode pre;
    public ListNode(){
        
    }
    public ListNode(int val){
        this.val = val;
    }
}

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 */
```

load factor, BST, Rehashing
```java
/*This code has been written with the help of this Link:
https://courses.cs.washington.edu/courses/cse373/13wi/lectures/02-11/HashSet.java
*/
class MyHashSet {
    
    BSTNode [] elements; //my elements are stored in binary trees!
    int size;
    final static double LOAD_FACTOR = 0.7;
    final static int INITIAL_SIZE = 1; // 100 was picked totally random! No thoughts behind it.
    
    public MyHashSet() {
        elements = (BSTNode[]) new BSTNode[INITIAL_SIZE];
		size = 0;
    }
    
    public void add(int key) {
	    int h = hash(key);
	    BSTNode newNode = new BSTNode(key);
		if(elements[h]==null){
            elements[h]= newNode;
        }
        else{
            elements[h].add(newNode);
        }
		size++;
        if( size > (int)(LOAD_FACTOR*elements.length)){
               rehash(); 
        }
    }
    public void remove(int key) { 
        //for more efficiency it does not call contains() before removing an item
        //it rather checks if it exists while removing
        int h=hash(key);
        if(elements[h]!=null)
            elements[h] = elements[h].remove(key);
        size--;
        
    }
    
    /** Returns true if this set contains the specified element */
    public boolean contains(int key) {
        int h=hash(key);
        if(elements[h]!=null)
            return elements[h].contains(key);
        return false;
    }
    
     private int hash(int key){
        return key % elements.length;
    }
    
    private void rehash(){
        BSTNode [] newElements = new BSTNode[elements.length*2];
        BSTNode [] old = elements;
        elements=newElements;
        for(BSTNode n:old){
            if(n!=null){
                LinkedList <BSTNode> list = n.allTreeNodes(); 
                ListIterator it=list.listIterator();
                while(it.hasNext()){
                    BSTNode node = (BSTNode)it.next();
                    add(node.data);
                }
            }
        }   
    }
    
    // Build in binary search tree node to take care of collisions, even long ones with ologn()
    private class BSTNode {
		public int data;
		private BSTNode right;
        private BSTNode left;
		
		protected BSTNode(int data) {
			this.data = data;
		}
        
        protected void add(BSTNode node){
            //The add function is recursive, since there are as many as log(n) function calls
            if(node.data>this.data){
                if(this.right==null){
                 this.right=node;   
                }else{
                    this.right.add(node);
                }
            }
            else if(node.data<this.data){
                if(this.left==null){
                 this.left=node;   
                }else{
                    this.left.add(node);
                }
            }
        }
        
        protected LinkedList<BSTNode> allTreeNodes(){ 
            // This function is iterative since there is n function calls,
            //although the size of the stack can get as big as h~log(n)
            // The reason linkedList is used here is that we just 
            //need to iterate over it once for rehashing!
            Queue<BSTNode> q =new LinkedList<>();
            q.add(this);
            LinkedList <BSTNode> list=new LinkedList<>();
            while(!q.isEmpty()){
                BSTNode node=q.poll();
                list.add(node);
                if(node.right!=null)q.add(node.right);
                if(node.left!=null)q.add(node.left);
            }
            return list;
        }
        
        protected boolean contains(int data){
            if(this.data==data)
                return true;
            if(this.data>data && this.left!=null)
                return this.left.contains(data);
            if(this.data<data && this.right!=null)
                return this.right.contains(data);
            return false;
        }
        
        protected BSTNode remove(int d){
            if(this.data==d){ //what we wanna remove is found
                
                if(this.right==null && this.left==null) //if leaf remove
                    return null;
                
                if(this.right==null || this.left==null) //if one child return that one child!
                    return (this.left!=null)?this.left:this.right;
                
                this.data=this.left.findMax().data; //substitude with the rightmost left successor
                this.left.remove(this.data);
            }
            
            if(this.data>d && this.left!=null)
                this.left=this.left.remove(d);
            
            if(this.data<d && this.right!=null)
                this.right=this.right.remove(d);
            
            return this;
        }
        
        private BSTNode findMax(){
            BSTNode node=this;
            while(node.right!=null){
                node=node.right;
            }
            return node;
        }
        
	}

}

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet obj = new MyHashSet();
 * obj.add(key);
 * obj.remove(key);
 * boolean param_3 = obj.contains(key);
 ["MyHashSet","add","add","contains","contains","add","contains","remove","contains"]
[[],[1],[2],[1],[3],[2],[2],[2],[2]]
 
 
 */
```
